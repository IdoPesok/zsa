---
title: "Procedure middleware"
group: "Getting Started"
groupOrder: 2
---

# Procedures

Procedures allow you to add additional context to a set of server actions, such as the `userId` of the caller. They are useful for ensuring certain actions can only be called if specific conditions are met, like the user being logged in or having certain permissions.

## Creating a basic procedure

To create your first procedure, follow this example:

```typescript:actions.ts
"use server"

const protectedProcedure = createServerActionProcedure()
  .noInputHandler(async () => {
    try {
        const {email, userId} = await getUserId();

        return {
            user: {
                email,
                userId,
            }
        }
    } catch {
        throw new Error("User not authenticated")
    }
  })

const protectedActionMiddleware = createServerActionWrapper(protectedProcedure)

export const updateEmailAction = protectedActionMiddleware
  .createAction()
  .input(z.object({
    newEmail: z.string()
  })).handler(async ({input, ctx}) => {
    const {user} = ctx

    // Update user's email in the database
    await db.update(users).set({
      email: newEmail,
    }).where(eq(users.id, user.userId))

    return newEmail
  })
```

In this example:

1. We create a `protectedProcedure` that verifies the user is logged in by calling `getUserId()`.
2. If successful, it returns the user's email and userId. If not, it throws an error.
3. We wrap the procedure in a `protectedActionMiddleware`.
4. We create an `updateEmailAction` using the middleware. This action can only be called if the user is logged in, and it has access to the user context.

## Creating a chained procedure

What if you need to restrict an action based on additional conditions, like the user being an admin? You can create a chained procedure that inherits functionality from another procedure:

```typescript:actions.ts
const adminProcedure = createServerActionProcedure()
  .input(z.object({ user: z.object({ userId: z.number() }) }))
  .handler(async ({ input }) => {
    if (input.user.userId !== 1) throw new Error("You are not authorized")

    return {
      user: input.user,
      isAdmin: true,
      message: `hello ${input.user}`,
    } as const
  })

const adminActionMiddleware = protectedAction.chainProcedure(adminProcedure)

export const deleteUserAction = adminActionMiddleware
  .createAction()
  .input(z.object({
    userIdToDelete: z.string()
  })).handler(async ({input, ctx}) => {
    const {user, isAdmin, message} = ctx

    // Delete user from database
    await db.delete(users).where(eq(users.id, userIdToDelete))
  })
```

In this example:

1. We create an `adminProcedure` that verifies the user is an admin (userId == 1).
2. We chain this procedure to the `protectedProcedure` to create an `adminActionMiddleware`.
3. Actions created from this middleware, like `deleteUserAction`, will first run the `protectedProcedure`, then the `adminProcedure`, before executing their own logic.
4. The action has access to the user context and admin status returned by the chained procedures.

## Procedures with input

You can also create procedures that require certain input, such as requiring a `postId`, and validate that the user has access to that resource for all derived actions:

```typescript:actions.ts
const postProcedure = createServerActionProcedure(protectedProcedure)
  .input(
    z.object({ postId: z.string() })
  )
  .handler(async ({ input, ctx }) => {

    //validate post ownership
    const ownsPost = await checkUserOwnsPost(ctx.user.userId, input.postId)
    if (!ownsPost) {
      throw new Error("UNAUTHORIZED")
    }

    return {
      user: ctx.user,
      post: {
        id: input.postId,
      },
    }
  })
```

Actions using this `postProcedure` will always require a `postId` input and validate the user's ownership before executing:

```typescript:actions.ts
const wrapper = createServerActionWrapper()
    .procedure(protectedProcedure)
    .chainProcedure(postProcedure)

const updatePostName = wrapper
    .createAction()
    .input(z.object({ newPostName: z.string() }))
    .handler(async ({ input, ctx }) => {
      console.log({
        // input contains postId and newPostName
        newPostName: input.newPostName,
        postId: input.postId,
        // ctx contains user and post returned by procedures
        user: ctx.user,
        post: ctx.post,
      })

      return "GREAT SUCCESS"
    })
```

## Building procedure chains

By creating individual procedures and chaining them together with `chainProcedure`, you can build up functionality in a modular way.

For example, if you have `procedure1`, `procedure2`, and `procedure3`, you can:

- Chain `procedure1` and `procedure2` to create `procedure12`
- Chain `procedure2` and `procedure3` to create `procedure23`, without utilizing any logic from `procedure1`.

This allows you to mix and match procedures as needed to enforce the desired conditions on your server actions.
